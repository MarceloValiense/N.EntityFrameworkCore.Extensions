using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata;
using N.EntityFrameworkCore.Extensions.Sql;
using N.EntityFrameworkCore.Extensions.Util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace N.EntityFrameworkCore.Extensions
{
    internal partial class BulkOperation<T>
    {
        internal async Task<BulkInsertResult<T>> BulkInsertStagingDataAsync(IEnumerable<T> entities, bool keepIdentity = false, bool useInternalId = false, CancellationToken cancellationToken = default)
        {
            IEnumerable<string> columnsToInsert = GetStagingColumnNames(keepIdentity);
            string internalIdColumn = useInternalId ? Common.Constants.InternalId_ColumnName : null;
            await Context.Database.CloneTableAsync(SchemaQualifiedTableNames, StagingTableName, TableMapping.GetQualifiedColumnNames(columnsToInsert), internalIdColumn, cancellationToken);
            StagingTableCreated = true;
            return await DbContextExtensionsAsync.BulkInsertAsync(entities, Options, TableMapping, Connection, Transaction, StagingTableName, columnsToInsert, SqlBulkCopyOptions.KeepIdentity, useInternalId, cancellationToken);
        }
        internal async Task<BulkMergeResult<T>> ExecuteMergeAsync(Dictionary<long, T> entityMap, Expression<Func<T, T, bool>> mergeOnCondition,
            bool autoMapOutput, bool insertIfNotExists, bool update = false, bool delete = false, CancellationToken cancellationToken = default)
        {
            int rowsInserted = 0;
            int rowsUpdated = 0;
            int rowsDeleted = 0;
            int rowsAffected = 0;
            var outputRows = new List<BulkMergeOutputRow<T>>();

            foreach (var entityType in TableMapping.EntityTypes)
            {
                rowsInserted = 0;
                rowsUpdated = 0;
                rowsDeleted = 0;

                var columnsToInsert = TableMapping.GetColumnNames(entityType).Intersect(GetColumnNames(entityType));
                var columnsToUpdate = update ? TableMapping.GetColumnNames(entityType).Intersect(GetColumnNames(entityType)) : new string[] { };
                var autoGeneratedColumns = autoMapOutput ? TableMapping.GetAutoGeneratedColumns(entityType) : new string[] { };
                var columnsToOutput = GetMergeOutputColumns(autoGeneratedColumns, delete);

                string mergeOnConditionSql = insertIfNotExists ? CommonUtil<T>.GetJoinConditionSql(mergeOnCondition, PrimaryKeyColumnNames, "t", "s") : "1=2";
                var mergeStatement = SqlStatement.CreateMerge(StagingTableName, entityType.GetTableName(),
                    mergeOnConditionSql, columnsToInsert, columnsToUpdate, columnsToOutput, delete);

                if (autoMapOutput)
                {
                    var propertiesForAdd = TableMapping.GetEntityProperties(entityType, ValueGenerated.OnAdd);
                    var propertiesForUpdate = TableMapping.GetEntityProperties(entityType, ValueGenerated.OnAddOrUpdate);
                    var bulkQueryResult = await Context.BulkQueryAsync(mergeStatement.Sql, Connection, Transaction, Options, cancellationToken);
                    rowsAffected = bulkQueryResult.RowsAffected;

                    foreach (var result in bulkQueryResult.Results)
                    {
                        string action = (string)result[0];
                        outputRows.Add(new BulkMergeOutputRow<T>(action));

                        if (action == SqlMergeAction.Delete)
                        {
                            rowsDeleted++;
                        }
                        else
                        {
                            int entityId = (int)result[1];
                            var entity = entityMap[entityId];
                            if (action == SqlMergeAction.Insert)
                            {
                                rowsInserted++;
                                if (propertiesForAdd.Count() > 0)
                                {
                                    var entityValues = GetMergeOutputValues(columnsToOutput, result, propertiesForAdd);
                                    Context.SetStoreGeneratedValues(entity, propertiesForAdd, entityValues);
                                }
                            }
                            else if (action == SqlMergeAction.Update)
                            {
                                rowsUpdated++;
                                if (propertiesForUpdate.Count() > 0)
                                {
                                    var entityValues = GetMergeOutputValues(columnsToOutput, result, propertiesForUpdate);
                                    Context.SetStoreGeneratedValues(entity, propertiesForUpdate, entityValues);
                                }
                            }
                        }
                    }
                }
                else
                {
                    rowsAffected = await Context.Database.ExecuteSqlAsync(mergeStatement.Sql, Options.CommandTimeout, cancellationToken);
                }
            }
            return new BulkMergeResult<T>
            {
                Output = outputRows,
                RowsAffected = rowsAffected,
                RowsDeleted = rowsDeleted,
                RowsInserted = rowsInserted,
                RowsUpdated = rowsUpdated,
            };
        }
        internal async Task<int> ExecuteUpdateAsync(IEnumerable<T> entities, Expression<Func<T, T, bool>> updateOnCondition, CancellationToken cancellationToken = default)
        {
            int rowsUpdated = 0;
            foreach (var entityType in TableMapping.EntityTypes)
            {
                IEnumerable<string> columnstoUpdate = CommonUtil.FormatColumns(GetColumnNames(entityType));
                string updateSetExpression = string.Join(",", columnstoUpdate.Select(o => string.Format("t.{0}=s.{0}", o)));
                string updateSql = string.Format("UPDATE t SET {0} FROM {1} AS s JOIN {2} AS t ON {3}; SELECT @@RowCount;",
                    updateSetExpression, StagingTableName, entityType.GetTableName(), CommonUtil<T>.GetJoinConditionSql(updateOnCondition, PrimaryKeyColumnNames, "s", "t"));
                rowsUpdated = await Context.Database.ExecuteSqlAsync(updateSql, Options.CommandTimeout, cancellationToken);
            }
            return rowsUpdated;
        }
    }
}
